# CGRA Compiler


### License: AGPL


### Assembler for Electron Nest

- "asm" directory

Electron Nest (EN) is CGRA-"like" microarchitecture (but very different from those arch types). EN does not needs adjustment of path length at place and route work in compilation, because the architecture supports synchronization for operands. Thus, the data-flow graph can be mapped on the EN's array without such the huge efforts.

SystemVerilog and testbenches: https://github.com/IAMAl/ElectronNest_SV


### CGRA Compiler Backend


<div align="center">
  <img src="https://github.com/IAMAl/ElectronNest_CP/blob/main/workflow_cgra.png"
       alt="HTML image alt text"
       title="Workflow for Generating Address Generation Program"
       width="550px"
  />
</div>

- "llvm" directory
- input: LLVM IR file
- output: LLVM IR file (address generation program)

Currently the backend generates only address generation program described by LLVM IR.
But the compilation has lots of path information and control-flow information, thus such the propaties can be used for constructing datapath and scheduling, repspectively.


#### 1. Generating Control-Flow and Data-Flow Graphs

- pyrhon gen_graph.py --src_name=your_source_llvm_ir_file_name --gen_type=select_cft_dfg_cdfg
- input: LLVM IR (.ll) file
- output: Graphviz format (dot file)

- gen_type
    - cfg: control-flow graph
    - dfg: data-flow graph
    - cdfg: both control- and dara- flow graphs

##### Options

- src_path: LLVM IR source file path, default: "."
- parse=[yes/no]: parsing LLVM IR file, default: "yes"
- nm_mode=[yes/no]: data-flow graph node representation takes mnemonic (in case of "yes"), otherwise instruction is taken, default: "yes"
- unique_id=[yes/no]: assign unique ID-number to graph nod, default: "yes"
- blobk=[yes/no]: extract data-flow graph for each basic block (in case of "yes"), otherwise entire data-flow graph is extracted, default: "yes"
- w_name: result file name, take same source file name when not specified, default: "None"
- w_path: result file path, default: "."


#### 2. Generating Adjacency Matrix

- pythhon gen_am.py --src_name=your_source_graph_file_name
- input: control- or data- flow graph generated by gen_graph.py
- output: adjacency matrix (text file), and corresponding node information

##### Options

- gen_type[cfg/dfg]: generate control-flow graph when "cfg" is specified, otherwise data-flow graph, default: "dfg"
- w_path: result file path, default: "."


#### 3. Generating Data-Flow Path in Basic Blocks

- python gen_path.py --src_name=source_am_file_name
- input: Adjacency Matrix file, generated by gen_am.py
- output: path information files (text files)

##### Options

- src_path: source file path, default "."
- w_path: result file path, default: "."
- format=[yes/no]: parsing LLVM IR file to work, default "no"


#### 4. Loop Detection in Control-Flow Graph

- python det_loop.py --src_name=source_cfg_file_name --w_name=output_file_name
- input: control-flow graph's adjacency matrix file generated by gen_am.py
- output: loop node list (text file)

##### Options

- src_path: source file path
- w_path: result file path


#### 5. Generating Address Generation Program (Under Testing)

- python gen_rog.py --src_name=source_cfg_file_name --cfg_name=llvm_ir_name
- input: control-flow graph's adjacency matrix file generated by gen_am.py, loop path list file generated by det_loop.py, node info files generated by gen_am.py, and path info files generated by gen_path.py
- output: LLVM IR (.ll) file (text file)

##### Options
- src_path: source file path, default: "."
- w_path: result file path, default "."


#### 6. Merging Nodes in Control-Flow Graph

- python mer_cfgnode.py --src_name=source_cfg_file_name
- input: LLVM IR (.ll) file
- output: merged LLVM IR file (text file)

##### Options

- src_path: source file path
- w_path: result file path
- w_name: result file name, default: "agu_prog.ll"